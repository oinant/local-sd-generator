"""Service for extracting metadata from SD-generated PNG images."""

import re
from pathlib import Path
from typing import Any, Optional

from PIL import Image


def extract_png_metadata(image_path: str | Path) -> dict[str, Any]:
    """
    Extract metadata from PNG image generated by Stable Diffusion WebUI.

    Reads the 'parameters' chunk from PNG metadata which contains:
    - Full prompt
    - Negative prompt
    - Generation parameters (seed, steps, cfg_scale, sampler, etc.)

    Args:
        image_path: Path to PNG image file

    Returns:
        Dictionary containing parsed metadata

    Raises:
        FileNotFoundError: If image does not exist
        ValueError: If image has no metadata or invalid format
    """
    image_path = Path(image_path)

    if not image_path.exists():
        raise FileNotFoundError(f"Image not found: {image_path}")

    # Open image and read PNG info
    try:
        with Image.open(image_path) as img:
            # Get 'parameters' chunk (SD WebUI standard)
            parameters = img.info.get('parameters', '')
    except Exception as e:
        raise ValueError(f"Failed to read image: {e}") from e

    if not parameters:
        raise ValueError("Image has no metadata (missing 'parameters' chunk)")

    # Parse SD WebUI metadata format (same logic as AUTOMATIC1111)
    # Last line = parameters (Steps:, Sampler:, etc.)
    # Everything before = prompt + negative prompt (can be multiline)

    lines = parameters.strip().split('\n')

    # Separate last line from the rest
    if len(lines) > 0:
        *prompt_lines, lastline = lines
    else:
        prompt_lines = []
        lastline = ''

    # Check if lastline actually contains parameters (at least 2 param matches)
    re_param = re.compile(r'(\w[\w \-/]+):\s*("(?:[^"]*)"|[^,]*?)(?:,|$)')
    param_matches = re_param.findall(lastline)

    if len(param_matches) < 2:
        # Not enough parameters, so lastline is part of prompt
        prompt_lines.append(lastline)
        lastline = ''

    # Parse prompt and negative prompt from prompt_lines
    prompt = ''
    negative_prompt = ''
    done_with_prompt = False

    for line in prompt_lines:
        line = line.strip()
        if line.startswith('Negative prompt:'):
            done_with_prompt = True
            line = line[16:].strip()  # Remove "Negative prompt:" prefix

        if done_with_prompt:
            negative_prompt += ('\n' if negative_prompt else '') + line
        else:
            prompt += ('\n' if prompt else '') + line

    # Parse parameters from lastline
    params_dict: dict[str, Any] = {}
    for key, value in param_matches:
        key = key.strip()
        value = value.strip()

        # Remove quotes if present
        if value.startswith('"') and value.endswith('"'):
            value = value[1:-1]

        params_dict[key] = value

    # Build structured metadata
    metadata = {
        'prompt': prompt,
        'negative_prompt': negative_prompt,
        'seed': _parse_int(params_dict.get('Seed'), -1),
        'steps': _parse_int(params_dict.get('Steps'), 20),
        'sampler': params_dict.get('Sampler', ''),
        'scheduler': params_dict.get('Schedule type', ''),
        'cfg_scale': _parse_float(params_dict.get('CFG scale'), 7.0),
        'size': params_dict.get('Size', ''),
        'model': params_dict.get('Model', ''),
        'model_hash': params_dict.get('Model hash', ''),
        'clip_skip': _parse_int(params_dict.get('Clip skip')),
        'denoising_strength': _parse_float(params_dict.get('Denoising strength')),
        'hires_upscaler': params_dict.get('Hires upscaler'),
        'hires_steps': _parse_int(params_dict.get('Hires steps')),
        'hires_resize': params_dict.get('Hires resize'),
        'version': params_dict.get('Version'),
        # Store all params for additional access
        'all_params': params_dict,
        # Store raw for debugging
        'raw_parameters': parameters,
    }

    # Parse size into width/height
    if metadata['size']:
        size_parts = metadata['size'].split('x')
        if len(size_parts) == 2:
            metadata['width'] = _parse_int(size_parts[0])
            metadata['height'] = _parse_int(size_parts[1])

    return metadata


def _parse_int(value: Optional[str], default: Optional[int] = None) -> Optional[int]:
    """Parse integer from string, return default if invalid."""
    if value is None:
        return default
    try:
        return int(float(value))  # Handle "42.0" format
    except (ValueError, TypeError):
        return default


def _parse_float(value: Optional[str], default: Optional[float] = None) -> Optional[float]:
    """Parse float from string, return default if invalid."""
    if value is None:
        return default
    try:
        return float(value)
    except (ValueError, TypeError):
        return default
