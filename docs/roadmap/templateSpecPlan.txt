  Plan de Documentation - Template System V2.0

  Structure des documents

  📄 Document 1 : template-system-v2-spec.md

  Spec Technique Formelle (~150-200 lignes)

  Sections :
  1. Vue d'ensemble
    - Objectifs du système V2.0
    - Concepts clés (templates, chunks, variations, imports)
    - Différences majeures avec V1.x
  2. Grammaire formelle (EBNF)
    - Syntaxe des placeholders : {Name}, {Name[selectors]}
    - Syntaxe des chunks : @Name, @{Name with ...}
    - Syntaxe des sélecteurs : [15], [#1,3,5], [$8], [key1,key2], combinaisons avec ;
    - Syntaxe with : @{Chunk with Placeholder:{Import[selectors]}}
  3. Structure des fichiers
    - Format .template.yaml (champs obligatoires/optionnels)
    - Format .chunk.yaml (champs obligatoires/optionnels)
    - Format .prompt.yaml (champs obligatoires/optionnels)
    - Format .yaml variations (dict simple)
  4. Placeholders réservés
    - Table par type de fichier (template, chunk, prompt, variation)
    - Validation contextuelle
  5. Système d'héritage (implements:)
    - Résolution des chemins (relatif au fichier)
    - Merge des sections (parameters, imports, chunks, defaults)
    - Validation des types de chunks
  6. Système d'imports
    - Fichiers vs inline strings
    - Merge multi-sources (ordre préservé)
    - Détection des conflits de clés
    - Référence par clé (Import.Key)
  7. Résolution des templates
    - Ordre de résolution (validation en 5 phases)
    - Injection de chunks avec @
    - Passage de paramètres avec with
    - Sélection de variations avec []
  8. Normalisation des prompts
    - Trim espaces
    - Collapse virgules multiples
    - Suppression virgules orphelines
    - Normalisation espaces autour virgules
    - Préservation 1 ligne vide max
  9. Gestion d'erreurs
    - Validation fail-fast (collecter toutes les erreurs)
    - Format JSON des erreurs
    - Logging dans output_dir/session_name/errors.json
    - Affichage pretty en console
  10. Tables de référence
    - Champs par type de fichier (tableau complet)
    - Sélecteurs supportés (syntaxe + signification)
    - Placeholders réservés (par contexte)

  ---
  📄 Document 2 : template-system-v2-architecture.md

  Architecture & Plan d'Implémentation (~200-250 lignes)

  Sections :

  1. Vue d'ensemble de l'architecture
    - Diagramme des modules (ASCII art)
    - Flux de données (du fichier YAML au prompt final)
    - Intégration avec le système existant
  2. Modules Python

  2. 2.1. Loader & Parser (templating/loaders/)
  # yaml_loader.py
  class YamlLoader:
      def load_file(path, base_path) -> dict
      def resolve_path(path, base_path) -> Path

  # template_parser.py
  class TemplateParser:
      def parse_template(data: dict) -> TemplateConfig
      def parse_chunk(data: dict) -> ChunkConfig
      def parse_prompt(data: dict) -> PromptConfig
      def parse_variations(data: dict) -> dict

  2. 2.2. Validation (templating/validators/)
  # validator.py
  class ConfigValidator:
      def validate(config) -> ValidationResult
      def collect_errors() -> list[ValidationError]

  # validation_error.py
  class ValidationError:
      type: str
      file: str
      line: int
      message: str

  2. 2.3. Resolution (templating/resolvers/)
  # inheritance_resolver.py
  class InheritanceResolver:
      def resolve_implements(config, cache) -> ResolvedConfig
      def merge_configs(parent, child) -> dict

  # import_resolver.py
  class ImportResolver:
      def resolve_imports(config) -> dict[str, Variations]
      def merge_variations(sources) -> dict
      def detect_conflicts(variations) -> list[str]

  # template_resolver.py (AMÉLIORATION du resolver.py existant)
  class TemplateResolver:
      def resolve_template(template, context) -> str
      def inject_chunks(template, chunks) -> str
      def apply_selectors(variations, selector) -> list

  2. 2.4. Data Models (templating/models/)
  # config_models.py
  @dataclass
  class TemplateConfig:
      version: str
      name: str
      implements: Optional[str]
      parameters: dict
      imports: dict
      template: str
      negative_prompt: str

  @dataclass
  class ChunkConfig:
      version: str
      type: str
      implements: Optional[str]
      imports: dict
      template: str
      chunks: dict
      defaults: dict

  @dataclass
  class PromptConfig:
      version: str
      name: str
      implements: str
      generation: GenerationConfig
      imports: dict
      template: str

  2. 2.5. Normalizer (templating/normalizers/)
  # prompt_normalizer.py
  class PromptNormalizer:
      def normalize(prompt: str) -> str
      def collapse_commas(text: str) -> str
      def trim_whitespace(text: str) -> str
      def preserve_single_newlines(text: str) -> str
  3. Flux de résolution détaillé
    - Diagramme de séquence (ASCII art)
    - Étapes de validation (5 phases)
    - Cache de résolution (éviter rechargements)
  4. Schémas de données
    - Structure en mémoire après parsing
    - Représentation des variations (dict avec clés)
    - Context de résolution (variables disponibles)
  5. Plan d'implémentation par phases

  5. Phase 1 : Fondations (Semaine 1)
    - Models + Loader + Parser basique
    - Tests unitaires (structures de données)

  Phase 2 : Validation (Semaine 2)
    - Validator avec 5 phases
    - Système d'erreurs JSON
    - Tests de validation

  Phase 3 : Résolution simple (Semaine 3)
    - Héritage (implements)
    - Merge de configs
    - Tests d'héritage

  Phase 4 : Imports & Variations (Semaine 4)
    - Import resolver
    - Détection conflits
    - Inline strings (MD5 hash)
    - Tests d'imports

  Phase 5 : Résolution de templates (Semaine 5)
    - Injection chunks (@)
    - Sélecteurs ([])
    - Syntaxe with
    - Tests de résolution

  Phase 6 : Normalisation (Semaine 6)
    - Normalizer
    - Tests de normalisation

  Phase 7 : Intégration & Rétrocompat (Semaine 7)
    - Détection version (v1.x vs v2.0)
    - Routage vers ancien/nouveau système
    - Tests d'intégration

  Phase 8 : Tests & Documentation (Semaine 8)
    - Tests end-to-end
    - Exemples réels
    - Documentation utilisateur
  6. Points d'intégration avec le code existant
    - CLI/src/templating/resolver.py : Refactoring vs nouveau module
    - CLI/src/templating/prompt_config.py : Extension pour v2.0
    - CLI/src/config/config_manager.py : Détection version
    - Backward compatibility hooks
  7. Tests strategy
    - Tests unitaires (par module)
    - Tests d'intégration (flux complet)
    - Tests de rétrocompatibilité
    - Fixtures exemples

  ---
  📄 Document 3 : template-system-v2-retrocompat.md

  Rétrocompatibilité V1.x ↔ V2.0 (~100 lignes)

  Sections :

  1. Détection de version
  def detect_version(config: dict) -> Version:
      version = config.get('version', '1.0.0')
      if version.startswith('1.'):
          return Version.V1
      elif version.startswith('2.'):
          return Version.V2
      else:
          raise ValueError(f"Unsupported version: {version}")
  2. Routage vers le bon système
  # Dans prompt_config.py ou nouveau entry point
  def load_prompt_config(path: Path) -> PromptConfig:
      data = yaml.safe_load(path)
      version = detect_version(data)

      if version == Version.V1:
          # Ancien système (resolver.py actuel)
          return legacy_load_prompt_config(data)
      else:
          # Nouveau système V2.0
          return v2_load_prompt_config(data)
  3. Cohabitation dans le même codebase
    - Structure des dossiers
  CLI/src/templating/
  ├── v1/                  # Legacy code (ancien resolver.py)
  │   ├── resolver.py
  │   └── variation_loader.py
  ├── v2/                  # Nouveau système
  │   ├── loaders/
  │   ├── validators/
  │   ├── resolvers/
  │   └── models/
  └── version_router.py    # Point d'entrée unifié
  4. Migration guidelines (pour l'utilisateur)
    - Pourquoi passer à v2.0
    - Exemples de conversion (concepts clés)
    - Timeline de dépréciation v1.x (si applicable)
  5. Tests de non-régression
    - Tous les anciens tests v1.x doivent passer
    - Nouveaux tests v2.0
    - Tests mixtes (projet avec v1 et v2)

  ---
  Ordre de rédaction

  1. Aujourd'hui (Passe actuelle) : Créer le plan (✅ EN COURS)
  2. Document 1 : template-system-v2-spec.md (spec formelle) → Base de tout
  3. Document 2 : template-system-v2-architecture.md (architecture) → Plan d'implémentation
  4. Document 3 : template-system-v2-retrocompat.md (rétrocompat) → Intégration

  ---
  Informations clés à inclure dans chaque doc

  Pour la Spec (Doc 1) :

  - ✅ Toutes les réponses des Passes 1-5 de templateSpec.md
  - ✅ Grammaire EBNF précise
  - ✅ Exemples concrets pour chaque feature
  - ✅ Tables de référence rapide

  Pour l'Architecture (Doc 2) :

  - ✅ Modules Python avec interfaces claires
  - ✅ Diagrammes ASCII (classes, séquence, flux)
  - ✅ Plan d'implémentation en 8 phases
  - ✅ Points d'intégration avec code existant

  Pour la Rétrocompat (Doc 3) :

  - ✅ Détection version (v1.x vs v2.0+)
  - ✅ Routage transparent
  - ✅ Structure de dossiers pour cohabitation
  - ✅ Tests de non-régression

  ---
  Voulez-vous que je commence maintenant par le Document 1 (Spec Formelle) ?

  Je vais créer un document ultra-détaillé avec :
  - Grammaire EBNF formelle
  - Tous les exemples de la spec workshop
  - Tables de référence complètes
  - Règles de validation précises

  Ça vous convient ?

  Todos
  ☐ Créer le plan de documentation complet (structure, sections, priorités)
  ☐ Rédiger template-system-v2-spec.md (grammaire EBNF, tables de référence, règles de validation)
  ☐ Rédiger template-system-v2-architecture.md (diagrammes de classes, flux, schemas, plan d'implémentation)
  ☐ Créer template-system-v2-retrocompat.md (détection version, cohabitation v1/v2)